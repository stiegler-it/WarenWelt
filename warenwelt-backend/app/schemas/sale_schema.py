from pydantic import BaseModel, Field, validator
from typing import List, Optional
from decimal import Decimal
from datetime import datetime

from .product_schema import ProductRead # For displaying product details within a sale item
from .user_schema import UserRead # For displaying user details in SaleRead
from app.models.sale_model import PaymentMethodEnum

# === SaleItem Schemas ===

class SaleItemBase(BaseModel):
    product_id: int
    quantity: int = Field(1, gt=0)
    # price_at_sale and commission_amount_at_sale will be determined by the service layer
    # based on the product's current prices when the sale is created.

class SaleItemCreate(SaleItemBase):
    # SKU can be provided by frontend to identify product
    sku: Optional[str] = Field(None, description="Product SKU, alternative to product_id for identifying product.")

    @validator('product_id', 'sku', pre=True, always=True)
    def check_product_identifier(cls, v, values, field):
        if field.name == 'product_id' and v is not None:
            if values.get('sku') is not None:
                raise ValueError("Provide either product_id or sku, not both.")
        if field.name == 'sku' and v is None and values.get('product_id') is None:
             raise ValueError("Either product_id or sku must be provided for a sale item.")
        return v


class SaleItemRead(SaleItemBase):
    id: int
    sale_id: int
    price_at_sale: Decimal
    commission_amount_at_sale: Decimal
    product: ProductRead # Embed full product details

    class Config:
        from_attributes = True


# === Sale Schemas ===

class SaleBase(BaseModel):
    # transaction_number will be auto-generated by the service layer.
    # user_id will be taken from the authenticated user by the service layer.
    # total_amount will be calculated by the service layer based on items.
    payment_method: PaymentMethodEnum
    # customer_id: Optional[int] = None # For future customer tracking

class SaleCreate(SaleBase):
    items: List[SaleItemCreate] = Field(..., min_length=1)

class SaleRead(SaleBase):
    id: int
    transaction_number: str
    user_id: int
    # user: UserRead # Embed user details, if needed. Requires User model to have 'sales' relationship if back_populates.
    total_amount: Decimal
    transaction_time: datetime
    items: List[SaleItemRead] # Embed list of sale items

    class Config:
        from_attributes = True
